<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <title>CleanCOde</title>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#">BITS</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="#">Home <span class="sr-only"></span></a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#nombres">Nombres</a>
                </li>               
                <li class="nav-item">
                    <a class="nav-link" href="#funciones">Funciones</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#comentarios">Comentarios</a>
                </li>      
                <li class="nav-item">
                    <a class="nav-link" href="#formato">Formato</a>
                </li>     
                <li class="nav-item">
                    <a class="nav-link" href="#objeto">Objeto</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#errores">Errores</a>
                </li>        
                <li class="nav-item">
                    <a class="nav-link" href="#limites">Límites</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#pruebas">Pruebas</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#clases">Clases</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#sistemas">Sistemas</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#emergencia">Emergencia</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#cocurrencia">Concurrencia</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#refinamiento">Refinamiento</a>
                </li> 
                <li class="nav-item">
                    <a class="nav-link" href="#jUnit">jUnit</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#refactorizacion">Refactorizacion</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#heuristica">Heurística</a>
                </li>
            </ul>
        </div>
    </nav>
    <div class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Clean Code</h1>
            La responsabilidad del código limpio es 100% de los programadores, su labor es defenderlo y negarse a hacer código incorrecto 
            (¿dejaría un médico que le pidieran que no se lavara las manos antes de una operación?). 
            El código limpio es la única alternativa para avanzar.
            El código limpio se caracteriza por ser elegante, eficaz, legible, mínimo, hacer solo una cosa bien de una única manera 
            y tener pruebas unitarias. Metáfora de las ventanas rotas, el código incorrecto es el principio del desastre. 
            Leemos 10:1 más código del que escribimos, no podremos escribir código si el de alrededor es ilegible. 
            Regla del Boy Scout, dejar el código más limpio de lo que me lo encontré.
        </div>
    </div>
    <div id="nombres" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Nombres Con Sentido</h1>
            <ul>
                <li>
                    Todos los nombres deben ser intencionados y descriptivos. Evita abreviaciones, prefijos, usar secuencias de números en variables y 
                    las palabras redundantes (the-, a-, -object, -info, -data). Usa nombres que se puedan buscar (evita variables a, e, l… usar i, j, k 
                    solo para bucles cuyo contexto sea muy acotado).
                </li>
                <li>
                    Es mejor usar un código en la implementación (que será privada y usada menos veces) que la interfaz => IShapeFactory, ShapeFactory —> ShapeFactory, ShapeFactoryImp
                </li>
                <li>
                    <b>Nombres de clases :</b> Evitar sufijos Manager o Processor. No deben ser verbos.
                </li>
                <li>
                    <b>Nombres de métodos :</b> Utiliza verbos. Usa get y set para métodos de acceso e is para booleanos. 
                </li>
                <li>
                    Usa métodos estáticos con nombres con el tipo de argumento en lugar de sobrecargar 
                    constructores (new Complex(23.0) –> Complex.FromRealNumber(23.0))
                </li>
                <li>
                    No usar juegos de palabras, chistes o sutilezas. Intentar usar siempre las mismas palabras para 
                    lo mismo (get, fetch, retrieve?). No usar una misma palabra para cosas distintas (add es sum o insert?).
                </li>
                <li>
                    Usa nombres técnicos cuando la intención sea técnica (Factory, Visitor, Facade, …) y nombres de dominio para conceptos de dominio.
                </li>
                <li>
                    Añade contexto a las variables, por ejemplo, agrupándolas en clases.
                </li>
                <li>
                    Los nombres cuanto más cortos mejor, siempre que sean explícitos y claros.
                </li>
            </ul>
        </div>
    </div>
    <div id="funciones" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Funciones</h1>
            <ul>
                <li>
                    Deben ser reducidas (~20 líneas) y con nombres descriptivos (no importan si son un poco largos). 
                </li>
                <li>
                    Debemos evitar el anidamiento excesivo (~complejidad ciclomática). 
                </li>
                <li>
                    Solo deben hacer una cosa. Para adivinar si una función hace más de una cosa intentamos describirla en una frase: “PARA (nombredefunción) […]”. 
                    Ej: “Para RenderPageWithSetup comprobamos si la página es de prueba y en caso afirmativo añadimos configuración y detalles. 
                    En cualquier caso, renderizamos en HTML”. 
                    Todo el contenido de una función debería estar al mismo nivel de abstracción. 
                    De igual forma, el siguiente nivel de abstracción debería estar en la función que sigue. 
                    De esta forma una clase se puede leer secuencialmente de arriba hacia abajo.
                </li>
                <li>
                    Evitar instrucciones switch en funciones escondiéndolas en clases abstractas (patrón Factory+strategy).
                </li>
                <li>
                    No deberían tener más de 2 parámetros, 3 ya son muchos y más de 3 una excepción que se debe justificar. 
                    Evitar los parámetros de salida pues son confusos, mejor funciones que retornen valor o que se llame a 
                    una función de clase del objeto que se cambia. Argumentos booleanos evitarlos, son síntoma de que la función 
                    hace al menos 2 cosas (1 si es true y otra si es false), en este caso mejor hacer 2 funciones, una para cada caso.
                </li>
                <li>
                    Funciones con 2 argumentos son válidas si los 2 argumentos están relacionados naturalmente, 
                    si no tienen nada que ver resultará confuso. Peor aún 3. Si podemos relacionarlos mejor hacer clases específicas 
                    con ellos que tengan sentido (Ej: Circle makeCircle(float x, float y, float radius) –> Circle makeCircle(Point p, float radius)).
                </li>
                <li>
                    Funciones sin efectos secundarios, que hagan lo que dice su nombre y nada más oculto (Ej: checkPassword que también llama a initializeSession). 
                    Normalmente asociado a hacer una sola cosa.
                </li>
                <li>
                    Funciones de comando o de consulta, pero nunca combinadas (solo una cosa).
                </li>
                <li>
                    Mejor devolver excepciones que códigos de error siempre (no implica capturar las excepciones inmediatamente y el código resulta más simple).
                </li>
                <li>
                    Si hay un bloque try/catch mejor simplificarlos extrayendo funciones para cada uno de los bloques 
                    (ej: try { hagoAlgoQuePuedeFallar(); } catch (Excepcion ex) { Logger.log(ex.message); }). 
                    Si hay try/catch en una función no debería haber nada más, si no seguro se está haciendo más de una cosa.
                </li>
                <li>
                    Todas las reglas que se han descrito son muy complicadas de seguir a la primera, 
                    la primera vez que se escribe una función es común violar la mayoría de reglas, aunque con trabajo iterativo adicional siempre se puede mejorar.
                </li>
            </ul>
            
            
            
        </div>
    </div>
    <div id="comentarios" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Comentarios</h1>
            Los comentarios solo están justificados cuando no somos capaces de expresarnos con el código. En general, basta con escribir y encapsular todo en una función que se llame como lo que hay en el comentario.
            Solo algunos comentarios son positivos:
            <ul>
                <li>
                    Comentarios legales, de derechos de autor
                </li>
                <li>
                    Comentarios informativos de lo que devuelve una función, aunque también se pueden eliminar si en el nombre de la función especificamos lo que se devuelve
                </li>
                <li>
                    Explicación de la intención, decisión tomada o advertencia
                </li>
                <li>
                    Cuando utilizamos librerías de terceros, que no podemos modificar los nombres de funciones
                </li>
                <li>
                    Comentarios TODO, aunque no deben ser excusa para dejar código incorrecto
                </li>
                <li>
                    Comentarios en API públicas (Javadoc)
                </li>
                <li>
                    Comentarios incorrectos: Que dejan dudas en la explicación, redundantes, obligatorios en javadoc, de registro de cambios (para ello está el control de código fuente), código comentado y comentarios sobre cosas que no están en el código adyacente.
                </li>
            </ul>
        </div>
    </div>
    <div id="formato" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Formato</h1>
            El tamaño de los ficheros no debería superar las 200 líneas de media, con un límite máximo en 500.

            Metáfora del periódico:
            <ul>
                <li>
                    Una clase comienza con un título descriptivo y una descripción sin detalles que explica el contenido.
                </li>
                <li>
                    Después vienen los detalles.
                </li>
                <li>
                    El módulo o programa es una compilación de artículos grandes y pequeños.
                </li>
                <li>
                    Podemos entender la clase con los métodos superiores sin necesidad de ahondar en los detalles
                </li>
                <li>
                    Separación de pensamientos y bloques con líneas en blanco (como separar en párrafos).
                </li>
            </ul>
            La distancia vertical entre elementos relacionados debe ser mínima, y como consecuencia, evitar separar elementos relacionados en 2 ficheros 
            distintos (razón por la cual no se deben usar variables protected)            
            Las variables se deben declarar lo más cerca posible a su uso. Las variables de clase (de instancia) en la parte superior, ya que se usan en toda la clase.            
            La anchura de las líneas de código, entre 80 y 120 caracteres, no deberíamos hacer scroll horizontal para leer código.            
            Los espacios en blanco se usan para separar conceptos que queremos remarcar o que están desconexos con sus antecesores y 
            predecesores. Ej: double determinant(double a, double b, double c) { return b*b – 4*a*c; }
            
            Intentar no romper el sangrado aunque la longitud de la función o while sea mínima, lo importante es la claridad.
            
            Cualquier equipo debería tener unas reglas convenientemente consensuadas. Es importante seguirlas por parte de todos, el estilo y formato debe ser siempre el mismo ya que el código es compartido.
        </div>
    </div>
    <div id="objeto" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Objetos y estructuras de datos</h1>
            Abstracción de los datos, se debe esconder la implementación de los datos de una clase y generar una interfaz (normalmente mediante métodos) para acceder y establecerlos, 
            siempre escondiendo la implementación concreta.
            Clase (esconde su implementación interna) vs estructura de datos (los expone tal cual)<br>
            Ley de Demeter: Solo debe invocar funciones de:
            <ul>
                <li>
                    Sí mismo
                </li>
                <li>
                    Variables locales
                </li>
                <li>
                    Un argumento
                </li>
                <li>
                    Una variable de instancia
                </li>
            </ul>
            Y no debe invocar funciones de objetos devueltos por llamadas a otras clases (ej:  a.getX().getY().getValue(); )
            Cuando tengamos esta necesidad hay que crear un método que devuelva el objeto de terceros que necesitamos (a.getXYValue();), o mejor, preguntarnos para qué necesito estos datos y traspasarle quizás la responsabilidad de ejecutar la acción al objeto a usar (a.doSomethingWithXYValue();). La ley de Demeter solo aplica a objetos, no a estructuras de datos simples.
            DTO = ejemplo de estructuras de datos útiles
            Active Record = DTO con métodos save y find, siguen sin ser objetos, son meras representaciones de un origen de datos, si queremos añadir métodos con lógica de negocio debemos crear clases aparte con variable de instancia interna de DTO
           
        </div>
    </div>
    <div id="errores" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Procesar Errores</h1>
            No usar códigos de error ya que confunden el flujo de ejecución y obligan al invocador a procesarlos inmediatamente.
            En los errores incluir información que nos dé contexto de dónde se ha producido el fallo.
            Al usar APIs de terceros siempre envolver excepciones (patrón facade).
            Crear clases para los casos especiales en lugar de dejar al código cliente procesar el caso excepcional (patrón caso especial, Fowler).
            En general no es recomendable devolver null, en su lugar es mejor devolver una excepción o un objeto de caso especial.
            Tampoco se debe pasar null como parámetro, a no ser que una librería de terceros espere un null. Al no haber una forma racional de controlar null para parámetros, evitarlo por convención es la mejor solución posible.
        </div>
    </div>
    <div id="limites" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Límites</h1>
            No es conveniente utilizar clases genéricas del sistema como valores de retorno de una de nuestras API. Normalmente tienen un exceso de funcionalidad que nuestro cliente no necesitará. Además, si la clase genérica cambia (poco probable pero no imposible), tendremos que cambiar el código de todos los clientes. Es mejor encapsular la implementación con la clase genérica en una clase propia que será la que usen los clientes.
            Si usamos código de terceros, generar unit tests de sus interfaces para comprobar que entendemos cómo funciona y se comporta como esperamos. Además, esto nos sirve para comprobar si nuevas versiones mantienen compatibilidad con lo que usamos de esa librería.
            Para usar cualquier librería de terceros usar el patrón Adapter (además permitirá comenzar la implementación sin tener aún el sistema con un FakeAdapter y hacer unit tests).
            Todo esto va enfocado a tener el mínimo de puntos a tocar si se produce algún cambio en el límite.
        </div>
    </div>
    <div id="pruebas" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Pruebas Unitarias</h1>
            3 leyes de TDD:
            <ol>
                <li>
                    No hay que crear código hasta que haya fallado un unit test
                </li>
                <li>
                    No hay que crear nunca más de una prueba que falle
                </li>
                <li>
                    El código creado debe ser el mínimo para que la prueba pase
                </li>
            </ol>
            ~30 segundos en hacer los 3 pasos aprox.
            
            Las pruebas al tener que evolucionar al mismo ritmo que el código, deben ser igualmente mantenibles y respetar las mismas reglas de código limpio.
            
            Las pruebas son la clave del desarrollo ágil, permiten hacer cambios sin temor a romper nada que funcione.
            
            En las pruebas es todavía más importante la legibilidad que en el código de producción. Evitar métodos muy largos con todos los detalles de implementación, es mejor que se lea claramente la estructura Arrange-Act-Assert de las pruebas escondiendo los detalles en métodos. Es común refactorizar código de unit tests y acabar en una API de pruebas. También es común penalizar el rendimiento a favor de la legibilidad ya que las pruebas nunca se ejecutarán en entorno productivo.
            
            Está permitido hacer más de un assert en una prueba, pero sí se debe cumplir que el número de asserts sea mínimo. Lo que sí se debe cumplir siempre es que solo se prueba una cosa en cada test.
            
            5 reglas para pruebas limpias: FIRST
            <ol>
                <li>
                    Fast
                </li>
                <li>
                    Independent, si son dependientes provocarán un fallo en cascada
                </li>
                <li>
                    Repetition, se deben poder repetir en cualquier entorno, incluso sin red
                </li>
                <li>
                    Self-Validating, o aciertan o fallan
                </li>
                <li>
                    Timely, se hacen antes del código porque si la haces después te dará pereza y acabarás por no probar
                </li>
            </ol>
        </div>
    </div>
    <div id="clases" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Clases</h1>
            Orden dentro de la clase: Contantes estáticas, variables estáticas, variables de instancia y funciones. De todo ello, primero lo público y después lo privado.
            El tamaño debe ser reducido, debe tener una única responsabilidad, la que indica su nombre. Nombres a evitar son Manager, Processor, Super ya que denotan muchas responsabilidades.
            Single Responsibility Principle, una clase debe tener un único motivo para cambiar.
            Cuando organizamos la complejidad del software, es mejor organizarla en cajones pequeños bien etiquetados que no en cajones de sastre enormes.
            Cohesión = grado de utilización de las variables de instancia por parte de las funciones. Queremos clases cohesionadas. Cuando se reduce el tamaño de las funciones se aumenta el tamaño de variables de instancia (para no pasarlas como parámetro a las subfunciones) y se pierde cohesión. En ese caso lo mejor es dividir en subclases.
            Open/Closed Principle = las clases deben estar abiertas a extensión y cerradas a modificación. Los cambios mejor que se hagan extendiendo o introduciendo nuevas clases, no modificando las existentes.
            Dependency Inversión Principle = las clases dependen de abstracciones, no de detalles concretos –> Imprescindible para unit testing.
        </div>
    </div>
    <div id="sistemas" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Sistemas</h1>
            Metáfora de la ciudad como el sistema, las responsabilidades se separan y una persona no puede controlar absolutamente todo y conocer todos los detalles. Las ciudades además se construyen poco a poco, las carreteras y demás servicios se van ampliando y acomodando a la demanda. Esto en software es todavía más fácil.
            Separar el proceso de construcción e inicio del uso del sistema o clase.
            Necesitamos un sitio centralizado donde abordar la construcción y resolver las dependencias. Una estrategia posible es generar todo desde main para después pasárselo a la aplicación (ya que la configuración es un aspecto global va a main).
            Patrón Factoría Abstracta –> Separar en una clase la responsabilidad de crear un objeto concreto para esconder los detalles de la creación.
            Inyección de dependencias –> Un objeto no es responsable de instanciar sus dependencias, lo delega a un sistema autorizado (normalmente main o un contenedor autorizado).
            AOP –> Modularizar aspectos transversales como persistencia, caché, excepciones… (Ejemplos, Spring, AspectJ)
            Una correcta separación de aspectos y modularidad es esencial para empezar proyectos software en pequeño e ir creciendo a medida que lo necesitemos.
            Arquitectura óptima = dominios implementados con POJO y conectados y armonizados con aspectos transversales mínimamente invasivos.
        </div>
    </div>
    <div id="emergencia" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Emergencia</h1>
            Según Ken Beck un diseño es sencillo cuando:
            <ul>
                <li>
                    Ejecuta todas las pruebas: Si se puede probar estamos seguros que hace lo que debe. Además, el diseñar muchas pruebas nos fuerza a hacer clases más pequeñas y con menos responsabilidades. Cuantas más pruebas, mejor diseño simple.
                </li>
                <li>
                    No contiene duplicados (REFACTORIZAR): Patrón de Template Method es muy usado para eliminar código duplicado.
                </li>
                <li>
                    Expresa la intención del programador (REFACTORIZAR)
                </li>
                <li>
                    Minimiza el número de clases y métodos (REFACTORIZAR): Es la menos importante de las 4, queremos sistemas simples o por ello con menos clases y métodos, pero no a costa de perder pruebas, aumentar duplicados o perder expresividad.
                </li>
            </ul>
            En la fase de refactorización es donde realmente aplicamos todos los aspectos vistos de código limpio: aumentar cohesión, dividir clases, modularizar aspectos, elegir nombres adecuados… Es imposible hacer un código limpio a la primera, así que es necesario refactorizar después de que el código funcione, y es necesario hacerlo antes de pasar a la siguiente tarea.
        </div>
    </div>
    <div id="concurrencia" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Concurrencia</h1>
            El hecho de separar el qué del cuándo en programación concurrente hace que tengamos que tomar precauciones para no tener problemas. Las prácticas a adoptar son:
            <ul>
                <li>
                    SRP, un único motivo para cambiar en cada clase –> separar el código que controla la concurrencia del código de la aplicación
                </li>
                <li>
                    Encapsula datos y protégelos con synchronized cuando se compartan entre procesos
                </li>
                <li>
                    Intentar minimizar la compartición de datos entre procesos, los procesos deben ser independientes
                </li>
                <li>
                    Utiliza las clases del entorno de desarrollo específicas de concurrencia (ej. Java.util.concurrent)
                </li>
            </ul>
            Distintos modelos: productor-consumidor, lector-escritor, la cena de los filósofos (condiciones de carrera), …
            Planificar y probar concienzudamente el código de cierre de un proceso, para evitar bloqueos en nuevos procesos.
            Recomendaciones:        
            <ul>
                <li>
                    Primero que funcione sin procesos, esto permite identificar los fallos que no tienen que ver con concurrencia
                </li>
                <li>
                    No ignorar los fallos que no se pueden reproducir
                </li>
                <li>
                    Se tienen que poder probar, mejor diseñar con esto en mente
                </li>
            </ul>
        </div>
    </div>
    <div id="refinamiento" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Refinamiento sucesivo</h1>
            Ejemplo de refactoring de una aplicación que parsea args pasados a main de 3 tipos (boolean, string e integer).
            El refactor consiste en hacer cambios pequeños poco a poco y que en cada paso pequeño pasen todos los tests.
            Los pasos concretos del refactor:
            <ul>
                <li>
                    Identificar el código o patrón de código que se repite. En este caso para cada tipo teníamos un parser de schema, un parser del valor y una función getBoolean(), getInteger()…
                </li>
                <li>
                    Creamos la clase ArgumentMarshaler como clase base, por ahora la clase no es abstracta ya que para empezar tendrá los métodos de tipo boolean (cambio más pequeño posible)
                </li>
                <li>
                    Añadir los métodos de integer y string en ArgumentMarshaler. Aunque sea la clase base lo primero es que el programa siga funcionando y antes de extraer clases heredadas de la clase base necesito toda la lógica en la clase base. Todo el marshaling está ahora en una sola clase, la clase base ArgumentMarshaler.
                </li>
                <li>
                    Introducimos instancias de la clase ArgumentMarshaler en lugar de los valores parseados de boolean y hacemos los retoques para que pase el compilador. Todo sigue funcionando.
                </li>
                <li>
                    Siguiente paso es pasar el código de boolean a BooleanArgumentMarshaler. Para ello hacemos ArgumentMarshaler clase abstracta y el parsing lo pasamos a funciones abstractas get y set. Cambiamos las instancias de ArgumentMarshaler por BooleanArgumentMarshaler en los casos de boolean.
                </li>
                <li>
                    Al pasar a abstracta necesito devolver Object en el método get() y hacer un Cast. Añado el control de la excepción ClassCastException.
                </li>
                <li>
                    Repetimos el proceso para integer y string.
                </li>
                <li>
                    Nos disponemos a eliminar los mapas de args por tipo, booleanArgs, stringArgs e intArgs. Para ello añado un mapa nuevo para los marshalers.
                </li>
                <li>
                    Puedo eliminar parámetros de funciones con este mapa, ya que con el id del arg puedo recuperar del mapa el marshaler
                </li>
                <li>
                    Paso parte del código de try catch de los diferentes marshalers de tipo a la clase base para no repetir código. En el marshaler de tipo mantengo la gestión de excepciones propia de cada tipo.
                </li>
                <li>
                    Queremos eliminar el switch de tipos en setArgument y cambiarlo por Marshaler.set. Primero se hace con boolean y cuando funciona con string e integer.
                </li>
                <li>
                    Al no quedar ningún método abstracto en la clase base podemos convertirla a interfaz.
                </li>
                <li>
                    Para comprobar que el código es limpio y escala, añadimos el tipo double.
                    <ul>
                        <li>
                            Primero hacemos un test que pase el happy path y añadimos la clase DoubleArgumentMarshaler y los cambios mínimos para que pase el test.
                        </li>
                        <li>
                            A continuación, hacemos un test por cada caso que pueda fallar y en cada uno vamos añadiendo código de control del error.
                        </li>
                    </ul>
                </li>
                <li>
                    El número de excepciones posible ha crecido mucho. Es mejor separar toda la lógica de excepciones en la clase ArgsException.
                </li>
                <li>
                    Finalmente movemos cada nueva clase a su archivo.
                </li>
            </ul>
        </div>
    </div>
    <div id="jUnit" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">jUnit</h1>
            Ejemplo de refactor con un módulo llamado ComparisonCompactor. Los cambios más importantes que hacemos son:
            <ul>
                <li>
                    Mejorar los nombres a las variables
                </li>
                <li>
                    Extraer una función de un condicional if para que nuestra intención quede clara (ej: if (a && b ==0 && c<30) –> if (shouldBeCompacted()). También se cambia el sentido del if para que la condición sea positiva (if (shouldNotBeCompacted()) –> if (shouldBeCompacted())
                </li>
                <li>
                    Renombrar función, ya que no solo compacta sino también formatea (compact() –> formatCompactedComparison(string message)).
                </li>
                <li>
                    Separamos la función en 2. formatCompactedComparison() formatea y compactExpectedAndActual() compacta
                </li>
                <li>
                    Vemos que findCommonPrefix y findCommonSuffix se tienen que llamar en orden. Para marcar esto hacemos que findCommonSuffix reciba preffixIndex como parámetro.
                </li>
                <li>
                    Nuevamente partimos findCommonPrefixAndSuffix() en 3 funciones, uno con una condición de if para que quede más claro y las otras 2 para extraer
                </li>
                <li>
                    Cambiamos las variables preffixIndex y suffixIndex por preffixLength y suffixLength para que sea más claro, y movemos la resta -1 a los lengths a la función charAtEnd() que es donde se utilizan los lengths (para la diferencia de base 0 y base 1).
                </li>
                <li>
                    Parece que sobran 2 ifs que comprueban longitud 0. Comentamos las líneas, ejecutamos pruebas y efectivamente en verde. Las eliminamos.
                </li>
            </ul>
        </div>
    </div>
    <div id="refactorizacion" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Refactorización del  SerailDate</h1>
            Ejemplo de refactor de la clase SerialDate de Jcommon, que implementa una clase más sencilla que java.util.Date ya que no incorpora información de las horas. Los pasos más importantes son:
            <ul>
                <li>
                    Cambiar el nombre de la clase por DayDate para esconder su implementación (la fecha se codifica con un número de serie)
                </li>
                <li>
                    Eliminar la herencia de MonthConstants y crear mi propio enum. Implica muchos cambios, pero elimino comprobaciones de códigos incorrectos y una función.
                </li>
                <li>
                    Existen 2 constantes MINIMUM_YEAR_SUPPORTED y MAXIMUM_YEAR_SUPPORTED públicas que no deben existir, ya que es una clase abstracta y no debe mostrar detalles de su implementación. El problema es que se usa en un método getFollowingDayOfWeek() que devuelve una clase concreta que hereda de DayDate, SpreadsheetDate. Para evitar que una clase abstracta deba conocer detalles de sus clases usuarias, utilizamos abstract factory DayDateFactory para que se encargue de gestionar la creación de instancias de DayDate y de los detalles de implementación.
                </li>
                <li>
                    Simplificamos y aumentamos expresividad de algunas funciones
                </li>
                <li>
                    Cambio addDays ya que es estática y opera variables de instancia, la pasamos a no estática.
                </li>
                <li>
                    Ídem con addMonths, y además lo hacemos más explícito con la explicación de variables temporales. Ídem addYears.
                </li>
                <li>
                    Cambio addDays y demás por plusDays para denotar que la instancia no sufre ningún cambio (solo se calcula el valor)
                </li>
                <li>
                    Cambiamos weekInMonthToString por la función toString dentro de una nueva enumeración weekInMonth
                </li>
                <li>
                    Cambiamos el método abstracto toDate que convierte a java.util.Date, no debería ser abstracto porque no depende de la implementación concreta. Lo subimos a DayDate.
                </li>
                <li>
                    Eliminamos comentarios de demás clases abstractas
                </li>
                <li>
                    Finalmente muevo todos los enums y clases nuevas a ficheros independientes
                </li>
                <li>
                    También las funciones estáticas resultantes las moveremos a una clase DateUtil.
                </li>
                <li>
                    También sustituimos el número mágico 1 por Month.JANUARY.toInt() y Day.toSunday.toInt().
                </li>
            </ul>
        </div>
    </div>
    <div id="heuristica" class="card" style="width: 100%;">
        <div class="card-body">
            <h1 class="card-title">Síntomas y Heurística</h1>
            Listado de olores que identifican problemas en el código (los que ya hayan salido en el libro los escribo, pero no los vuelvo a explicar):
            <b>
                Comentarios:
            </b>
            <ul>
                <li>
                    Informativos
                </li>
                <li>
                    Redundantes
                </li>
                <li>
                    Obsoletos
                </li>
                <li>
                    Mal escritos
                </li>
                <li>
                    Código comentado
                </li>
            </ul>
            <b>
                Entorno:
            </b>
            <ul>
                <li>
                    La generación de la solución (build) desde el control de código fuente es compleja, requiere más de un paso
                </li>
                <li>
                    Las pruebas requieren igualmente más de un paso, debería ser algo rápido y sencillo o no lo ejecutará con la frecuencia necesaria
                </li>
            </ul>
            <b>
                Funciones:
            </b>
            <ul>
                <li>
                    Demasiados argumentos, 0, 1, 2 o como mucho 3
                </li>
                <li>
                    Argumentos de salida
                </li>
                <li>
                    Argumentos de indicador (booleanos), son indicadores de que la función hace más de una cosa
                </li>
                <li>
                    Función muerta (nadie la usa)
                </li>
            </ul>
            <b>
                General:
            </b>
            <ul>
                <li>
                    Varios lenguajes en un mismo archivo de código
                </li>
                <li>
                    Comportamiento evidente no implementado, cuando un usuario espera que una función haga algo y ésta no lo hace se pierde la confianza y obliga a mirar qué hace el método por dentro
                </li>
                <li>
                    Comportamiento incorrecto de la función (en los límites, en casos extremos, excepciones…)
                </li>
                <li>
                    Medidas de seguridad canceladas temporalmente, nunca desactivar los tests, avisos del compilador, …
                </li>
                <li>
                    Duplicación (DRY): Los códigos repetidos se pasan a clases abstractas, los switchs con polimorfismo, y los algoritmos repetidos se cambian con el patrón plantilla o estrategia.
                </li>
                <li>
                    Código en un nivel de abstracción incorrecto (clase base abstracta sabe de lo general, clase heredada conoce los detalles)
                </li>
                <li>
                    Clases base que dependen de sus variantes
                </li>
                <li>
                    Exceso de información, es necesario ocultar la información de dentro de las clases, no queremos conocer los detalles, queremos saber lo mínimo y poder hacer lo máximo (interfaces pequeñas)
                </li>
                <li>
                    Código muerto (condiciones if o catch que nunca se dan)
                </li>
                <li>
                    Separación vertical estrecha
                </li>
                <li>
                    Incoherencia (si usas una convención o nombre para algo mantenlo en todo el código igual)
                </li>
                <li>
                    Desorden, elimina variables sin usar, ordena las declaraciones de variable, …
                </li>
                <li>
                    Conexiones artificiales, por comodidad dejar las variables fuera de sitio, funciones, …
                </li>
                <li>
                    Envidia de características, cuando una clase accede a get y set de una instancia de otra clase más de lo necesario es que envidia esa clase, es candidata a pasar a la clase envidiada, aunque a veces no hay más remedio
                </li>
                <li>
                    Argumentos boolean (selectores) que denotan varios comportamientos en una función (mejor separar en n funciones)
                </li>
                <li>
                    Intención desconocida o escondida, el código debe dejar clara la intención del autor
                </li>
                <li>
                    Responsabilidad desubicada, dejar los elementos donde el lector espera encontrarlos
                </li>
                <li>
                    Elementos estáticos incorrectos, una función será estática solo si no accede a variables de instancia o si no tiene sentido que sea polimórfica
                </li>
                <li>
                    Variables explicativas, usar variables temporales con nombres descriptivos para explicitar nuestra intención, aunque el código quede más largo
                </li>
                <li>
                    Nombres claros de función, si tenemos que leer documentación o mirar el código para ver qué hace, es candidata a cambiar de nombre
                </li>
                <li>
                    Comprender el algoritmo, más allá que pase las pruebas asegurarnos de que es correcto
                </li>
                <li>
                    Convertir dependencias lógicas en físicas (tiene que ver con funciones o constantes desubicadas)
                </li>
                <li>
                    Polimorfismo antes que if o switch, como regla general solo puede haber un switch por cada tipo de selección, si se repite el switch en otra parte del código es síntoma claro de que necesita polimorfismo
                </li>
                <li>
                    Seguir las normas de código
                </li>
                <li>
                    Sustituir números mágicos por constantes con nombres correctos, también aplica a strings
                </li>
                <li>
                    Precisión a la hora de tomar decisiones (utilizar float o int, return a[0], …)
                </li>
                <li>
                    Encapsular condicionales, evitar poner en los if cadenas de booleanos, mejor una subfunción con un nombre explícito
                </li>
                <li>
                    Evitar condicionales negativas
                </li>
                <li>
                    Funciones solo deben hacer una cosa
                </li>
                <li>
                    Las conexiones temporales deben ser visibles, por ejemplo, pasándole como parámetro el resultado de la primera función a la segunda, …
                </li>
                <li>
                    Evitar la arbitrariedad, las cosas en su sitio y que se vea claro por qué están es ese sitio
                </li>
                <li>
                    Las funciones solo deben bajar un nivel de abstracción
                </li>
                <li>
                    Mantener los datos configurables en los niveles superiores (las constantes por ejemplo)
                </li>
                <li>
                    Evitar desplazamientos transitivos (Ley de Demeter)
                </li>
            </ul>
            <b>
                Java:
            </b>
            <ul>
                <li>
                    Evitar usar comodines
                </li>
                <li>
                    No heredar constantes (es complicado después saber de dónde vienen, mejor declararlas en una clase como estáticas y llamarlas con el prefijo apropiado, o usar importación estática)
                </li>
                <li>
                    Usar enums en lugar de constantes
                </li>
            </ul>
            <b>
                Nombres:
            </b>
            <ul>
                <li>
                    Usar nombres descriptivos
                </li>
                <li>
                    Elegir nombres correctos para el nivel de abstracción
                </li>
                <li>
                    Usar nomenclatura estándar (usar nombres de patrones, nombres de funciones existentes tipo clone o toString, nombres del dominio…)
                </li>
                <li>
                    Nombres inequívocos para funciones, mejor largos pero que expresen lo que hacen
                </li>
                <li>
                    Usar nombres extensos para ámbitos extensos
                </li>
                <li>
                    Evitar codificaciones en los nombres
                </li>
                <li>
                    Deben describir efectos secundarios
                </li>
            </ul>
            <b>
                Tests:
            </b>
            <ul>
                <li>
                    Pruebas suficientes, se debe probar todo lo que pueda fallar
                </li>
                <li>
                    Usar herramientas de cobertura
                </li>
                <li>
                    No ignorar pruebas triviales, sobre todo por su labor de documentación
                </li>
                <li>
                    Usar pruebas ignoradas (@Ignore) para preguntar sobre ambigüedades
                </li>
                <li>
                    Probar condiciones de límite
                </li>
                <li>
                    Si detecta un error en una función, pruébela exhaustivamente porque es probable que haya más
                </li>
                <li>
                    Los patrones de fallo de las pruebas (también los de cobertura) son indicadores de una posible solución
                </li>
                <li>
                    Las pruebas deben ser rápidas
                </li>
            </ul>

        </div>
    </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  </body>
</html>