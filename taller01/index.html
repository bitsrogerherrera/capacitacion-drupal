<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>Document</title>
</head>

<body>
  <div class="header">
    <h1>Capacitación Drupal</h1>
  </div>
  <div class="clearfix">
    <div class="column menu">
      <ul>
        <li>Phasellus porttitor</li>
        <li>Curabitur velit</li>
        <li>Nam mattis</li>
        <li>Cras sit amet</li>
      </ul>
    </div>
    <div class="column content">
      <h1>Introducción</h1>
      <p>La responsabilidad del código limpio es 100% de los programadores, su labor es defenderlo y negarse a
        hacer código incorrecto.
        El código limpio es la única alternativa para avanzar.</p>
      <h1>Nombres con sentido</h1>
      <p>Todos los nombres deben ser intencionados y descriptivos. Evita abreviaciones, prefijos, usar secuencias
        de números en variables y las palabras redundantes</p>
      <p>ejemplo: no es lo mismo encontrar en una función</p>
      <code>
				int d; // número de días trabajados
			</code>
      <p>Que encontrar:</p>
      <code>
				int workedDays;
			</code>
      <p>Debemos evitar nombres que, en lugar de dar información, confunda al lector. Por ejemplo no usar
        accountList cuando el tipo no sea un List, porque nos puede confundir.</p>
      <h1>Funciones</h1>
      <P>Reglas a tener en cuenta </P>
      <ul>
        <li>La primera regla de las funciones es que deben ser de tamaño reducido. La segunda es que deben ser todavía
          más reducidas.</li>
        <li>Las funcones sólo deben hacer una cosa. Deben hacerlo bien y deben ser lo unico que hagan</li>
        <li> Los bloques en instrucciones if, else, while y similares deben tener una línea de longitud que,
          seguramente, sea la invocación de una función. De esta forma, no sólo se reduce el tamaño de la función, sino
          que también se añade valor documental ya que la función invocada desde el bloque puede tener un nombre
          descriptivo.</li>
        <li>Recuerde el principio de Ward: Sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo
          que esperábamos</li>
        <li>El número ideal de argumentos para una función es cero. Después uno (monádico) y dos (diádico). Siempre que
          sea posible, evite la presencia de tres argumentos (triádico). Más de tres argumentos (poliádico) requiere una
          justificación especial y no es muy habitual.</li>
        <li>writeField(name), que nos dice que name es un campo (field). Éste es un ejemplo de palabra clave como nombre
          de función.</li>
        <li>Los efectos secundarios son mentiras. Su función promete hacer una cosa, pero también hace otras cosas
          ocultas.</li>
      </ul>
      <p>
        Cuando necesitamos pasar más de 2 o 3 argumentos, es una clara señal de que varios pueden agruparse en un
        objeto. Viendo estos 2 ejemplos:
      </p>
      <code>
        Circle makeCircle(double x, double y, double radius);<br>
        Circle makeCircle(Point center, double radius);
      </code>
      <p>De buenas a primeras no sabría decir que significan X e Y, pero en el segundo ejemplo queda bastante claro (y
        es un claro indicador de que X e Y forman parte de un concepto que merece un nombre propio).</p>
      <h1>Comentarios</h1>
      <p>
        Solo algunos comentarios son positivos:
      </p>
      <ul>
        <li>Comentarios legales, de derechos de autor</li>
        <li>Comentarios informativos de lo que devuelve una función, aunque también se pueden eliminar si en el nombre
          de la función especificamos lo que se devuelve</li>
        <li>Explicación de la intención, decisión tomada o advertencia</li>
        <li>Cuando utilizamos librerías de terceros, que no podemos modificar los nombres de funciones</li>
        <li>Comentarios TODO, aunque no deben ser excusa para dejar código incorrecto</li>
        <li>Comentarios en API públicas (Javadoc)</li>
      </ul>
      <p>Comentarios incorrectos: Que dejan dudas en la explicación, redundantes, obligatorios en javadoc, de registro
        de cambios (para ello está el control de código fuente), código comentado y comentarios sobre cosas que no están
        en el código adyacente.</p>
      <h1>Formato</h1>
      <p>El tamaño de los ficheros no debería superar las 200 líneas de media, con un límite máximo en 500.</p>
      <p>Metafora del periódico</p>
      <ul>
        <li>Una clase comienza con un título descriptivo y una descripción sin detalles que explica el contenido.</li>
        <li>Después vienen los detalles.</li>
        <li>El módulo o programa es una compilación de artículos grandes y pequeños.</li>
        <li>Podemos entender la clase con los métodos superiores sin necesidad de ahondar en los detalles</li>
        <li>Separación de pensamientos y bloques con líneas en blanco (como separar en párrafos).</li>
      </ul>
      <h1>Objetos y estructuras de datos</h1>
      <p>Abstracción de los datos, se debe esconder la implementación de los datos de una clase y generar una interfaz (normalmente mediante métodos) para acceder y establecerlos, siempre escondiendo la implementación concreta.</p>
      <p>Ley de Demeter: Solo debe invocar funciones de:</p>
      <ul>
        <li>Si mismo</li>
        <li>variables locales</li>
        <li>Un argumento</li>
        <li>Una variable de instancia.</li>
      </ul>
      <p>Y no debe invocar funciones de objetos devueltos por llamadas a otras clases (ej:  a.getX().getY().getValue(); )</p>
      <h1>Procesar errores</h1>
      <ul>
        <li>No usar códigos de error ya que confunden el flujo de ejecución y obligan al invocador a procesarlos inmediatamente.</li>
        <li>En los errores incluir información que nos dé contexto de dónde se ha producido el fallo.</li>
        <li>Al usar APIs de terceros siempre envolver excepciones (patrón facade).</li>
        <li>Crear clases para los casos especiales en lugar de dejar al código cliente procesar el caso excepcional (patrón caso especial, Fowler).</li>
        <li>En general no es recomendable devolver null, en su lugar es mejor devolver una excepción o un objeto de caso especial.</li>
        <li>Tampoco se debe pasar null como parámetro, a no ser que una librería de terceros espere un null. Al no haber una forma racional de controlar null para parámetros, evitarlo por convención es la mejor solución posible.</li>
      </ul>
      <h1>Límites</h1>
      <p>No es conveniente utilizar clases genéricas del sistema como valores de retorno de una de nuestras API. Normalmente tienen un exceso de funcionalidad que nuestro cliente no necesitará.
        Además, si la clase genérica cambia,tendremos que cambiar el código de todos los clientes. Es mejor encapsular la implementación con la clase genérica en una clase propia que será la que usen los clientes.
      </p>
      <p>Para usar cualquier librería de terceros usar el patrón Adapter (además permitirá comenzar la implementación sin tener aún el sistema con un FakeAdapter y hacer unit tests).</p>
      <h1>Pruebas unitarias</h1>
      <p>leyes de TDD:</p>
      <ul>
        <li>No hay que crear código hasta que haya fallado un unit test</li>
        <li>No hay que crear nunca más de una prueba que falle</li>
        <li>El código creado debe ser el mínimo para que la prueba pase</li>
        <li>Las pruebas evolucionan al mismo paso que el codigo.</li>
        <li>Las pruebas son la clave para el desarrollo Agil, permiten hacer cambios sin temor a romper nada.</li>
        <li>Las pruebas ayudan a la legibilidad del código en producción. </li>
        <li>Está permitido hacer más de un assert en una prueba, pero sí se debe cumplir que el número de asserts sea mínimo. </li>
      </ul>
      <p>Reglas para pruebas limpias: FIRST</p>
      <ul>
        <li>Fast</li>
        <li>Independent, si son dependientes provocarán un fallo en cascada</li>
        <li>Repetition, se deben poder repetir en cualquier entorno, incluso sin red</li>
        <li>Self-Validating, o aciertan o fallan</li>
        <li>Timely, se hacen antes del código porque si la haces después te dará pereza y acabarás por no probar</li>
      </ul>
      <h1>Clases</h1>
      <p>Lo que debe cumplir una clase:</p>
      <ul>
        <li>Orden dentro de la clase: Contantes estáticas, variables estáticas, variables de instancia y funciones. De todo ello, primero lo público y después lo privado.</li>
        <li>El tamaño debe ser reducido, debe tener una única responsabilidad</li>
        <li>Single Responsibility Principle, una clase debe tener un único motivo para cambiar.</li>
        <li>Cuando organizamos la complejidad del software, es mejor organizarla en cajones pequeños.</li>
        <li>Cohesión = grado de utilización de las variables de instancia por parte de las funciones. Queremos clases cohesionadas. Cuando se reduce el tamaño de las funciones se aumenta el tamaño de variables de instancia (para no pasarlas como parámetro a las subfunciones) y se pierde cohesión.</li>
        <li>Open/Closed Principle = las clases deben estar abiertas a extensión y cerradas a modificación. Los cambios mejor que se hagan extendiendo o introduciendo nuevas clases, no modificando las existentes.</li>
        <li>Dependency Inversión Principle = las clases dependen de abstracciones, no de detalles concretos –> Imprescindible para unit testing.</li>
      </ul>
    </div>
  </div>
  <div class="footer">
    <p>Footer Text</p>
  </div>
</body>

</html>